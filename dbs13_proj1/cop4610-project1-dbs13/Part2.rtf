{\rtf1\ansi\ansicpg1252\cocoartf1404\cocoasubrtf340
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 Drew Smith\
COP4610\
Project 1\
Part II\
\
Tracing the read() system call:\
\
When the program executes the line "read(10, buf, n)", the return value gets placed into eax, which in this case, is an invalid file descriptor, so the return value gets set to -1. The function, \
\
	int read(int, void*, int);\
\
is declared on line 13 in user.h and defined in usys.S on line 16. \
\
SYSCALL(read) then expands to .globl read, which declares "read()" as a global symbol. The system call then places the return from the read function in the eax register. \
\
	movl $SYS_read, %eax;\
\
The system call then triggers a software interrupt and enters the kernal.\
\
In syscall.h, read is declared:\
	#define SYS_read    5\
\
On line 27, it gets passed to the processor defined exceptions/interupt vectors:\
	#define T_SYSCALL       64\
\
and triggers a software interupt. The CPU the saves the current state and calls the interupt handler. The interupt handler for T_SYSCALL is found in vectors.S, which is generated by vectors.pl. The interupt handler is "vector64".\
\
On line 318 in vectors.S,\
	vector64:\
  	pushl $0\
  	pushl $64\
  	jmp alltraps\
	.globl vector65\
\
we can see that vector64 jumps to the alltraps function. The alltraps function creates the "trapframe" and calls trap(), on line 37 in the file trap.c:\
\
	void trap(struct trapframe *tf)\
\
   In user space, the process is assumed to misbehave and forces the process exit if it has been killed and is in user space. If it is still executing in the kernel, let it keep running until it gets to the regular system call return. Last, the function checks to see if the process has been killed.\
\
Then, "struct trapframe" saves the user-space registers and tf->eax contains the system call number, (SYS_read).\
\
trap(tf) then calls syscall(void) because: \
	(tf->trapno == T_SYSCALL)\
\
and is saved to the current process control block. After returning, trap returns to alltraps, where it then restores the user registers and returns to the user space with iret.\
\
Within syscall.c, on line 94,\
	extern int sys_read(void);\
\
reads the syscall number in eax and calls sys_read. The return value is saved in tf->eax, control is then returned to the trap and sys_read, on line 108 of syscall.c, \
	\
	[SYS_read]    sys_read;\
\
Beginning on line 66 in sysfile.c, the system call gets passed to the function:\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf0 	\
	int sys_read(void)\
	\{\
  		struct file *f;\
  		int n;\
  		char *p;\
\
  		if(argfd(0, 0, &f) < 0 || argint(2, &n) < 0 || argptr(1, &p, n) < 0)\
    			return -1;\
  		\
		return fileread(f, p, n);\
	\}\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf0 reads the parameter from the user stack with "argdf". Since fd = 10 is an invalid file descriptor, sys_read returns -1.\
}